/*!
 * @file
 * @brief
 */

#include <stddef.h>
#include "stm32f30x_i2c.h"
#include "stm32f30x_rcc.h"
#include "stm32f30x_gpio.h"
#include "stm32f30x_misc.h"
#include "i2c1.h"

enum {
  // fixme are the reload ones necessary?
  // fixme is any of this necessary? seems like the peripheral basically does this for me
  mode_write,
  mode_write_with_reload,
  mode_read,
  mode_read_with_reload
};
typedef uint8_t mode_t;

static struct {
  i_tiny_i2c_t interface;

  mode_t mode;

  union {
    const uint8_t* write;
    uint8_t* read;
  } buffer;
  uint8_t buffer_size;
  uint8_t buffer_offset;

  tiny_i2c_callback_t callback;
  void* context;
} self;

void I2C1_EV_IRQHandler(void) {
  uint32_t flags = I2C_ReadRegister(I2C1, I2C_Register_ISR);

  // TX Interrupt Status
  if(flags & I2C_ISR_TXIS) {
    I2C_SendData(I2C1, self.buffer.write[self.buffer_offset++]);
    return;
  }

  // RX Not Empty
  if(flags & I2C_ISR_RXNE) {
    self.buffer.read[self.buffer_offset++] = I2C_ReceiveData(I2C1);
    return;
  }

  // Transfer Complete Reload
  if(flags & I2C_ISR_TCR) {
    // Condition is cleared on the start of the restart transfer
    self.callback(self.context, true);
    return;
  }

  // Stop condition generated by the peripheral
  if(flags & I2C_ISR_NACKF) {
    I2C_SoftwareResetCmd(I2C1);
    self.callback(self.context, false);
    return;
  }

  // Stop condition generated by the peripheral
  if(flags & I2C_ISR_STOPF) {
    I2C_ClearITPendingBit(I2C1, I2C_IT_STOPF);
    self.callback(self.context, true);
    return;
  }

  // If we're still here then something bad (or at least unexpected) happened
  I2C_SoftwareResetCmd(I2C1);
  self.callback(self.context, false);
}

void I2C1_ER_IRQHandler(void) {
  I2C_SoftwareResetCmd(I2C1);
  self.callback(self.context, false);
}

static void write(
  i_tiny_i2c_t* _self,
  uint8_t address,
  bool prepare_for_restart,
  const uint8_t* buffer,
  uint8_t buffer_size,
  tiny_i2c_callback_t callback,
  void* context) {
  (void)_self;

  self.buffer.write = buffer;
  self.buffer_size = buffer_size;
  self.buffer_offset = 0;
  self.mode = prepare_for_restart ? mode_write_with_reload : mode_write;
  self.callback = callback;
  self.context = context;

  I2C_TransferHandling(I2C1, address, buffer_size, prepare_for_restart ? I2C_Reload_Mode : I2C_AutoEnd_Mode, I2C_Generate_Start_Write);
}

static void read(
  i_tiny_i2c_t* _self,
  uint8_t address,
  bool prepare_for_restart,
  uint8_t* buffer,
  uint8_t buffer_size,
  tiny_i2c_callback_t callback,
  void* context) {
  (void)_self;

  self.buffer.read = buffer;
  self.buffer_size = buffer_size;
  self.buffer_offset = 0;
  self.mode = prepare_for_restart ? mode_read_with_reload : mode_read;
  self.callback = callback;
  self.context = context;

  I2C_TransferHandling(I2C1, address, buffer_size, prepare_for_restart ? I2C_Reload_Mode : I2C_AutoEnd_Mode, I2C_Generate_Start_Read);
}

static void reset(i_tiny_i2c_t* _self) {
  (void)_self;
  I2C_SoftwareResetCmd(I2C1);
}

static const i_tiny_i2c_api_t api = { write, read, reset };

static void configure_clocks(void) {
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
  // fixme necessary?
  // RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
  // RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
}

static void configure_pins(void) {
  GPIO_InitTypeDef gpio_init;
  gpio_init.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
  gpio_init.GPIO_Mode = GPIO_Mode_AF;
  gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
  gpio_init.GPIO_OType = GPIO_OType_OD;
  gpio_init.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(GPIOB, &gpio_init);

  GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_4);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_4);
}

static void configure_i2c1(void) {
  I2C_InitTypeDef i2c_init;
  i2c_init.I2C_Ack = I2C_Ack_Enable;
  i2c_init.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  i2c_init.I2C_AnalogFilter = I2C_AnalogFilter_Enable;
  i2c_init.I2C_DigitalFilter = 0;
  i2c_init.I2C_Mode = I2C_Mode_I2C;
  i2c_init.I2C_OwnAddress1 = 0;
  i2c_init.I2C_Timing = 0xC062121F; // Magic, pulled from sample for 72 MHz standard mode
  I2C_Init(I2C1, &i2c_init);

  I2C_ITConfig(
    I2C1,
    I2C_IT_RXI | I2C_IT_TXI | I2C_IT_STOPI | I2C_IT_TCI | I2C_IT_NACKI | I2C_IT_ERRI,
    ENABLE);

  I2C_Cmd(I2C1, ENABLE);
}

static void configure_event_interrupt(void) {
  NVIC_InitTypeDef nvic_init;
  nvic_init.NVIC_IRQChannel = I2C1_EV_IRQn;
  nvic_init.NVIC_IRQChannelPreemptionPriority = 1;
  nvic_init.NVIC_IRQChannelSubPriority = 0;
  nvic_init.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&nvic_init);
}

static void configure_error_interrupt(void) {
  NVIC_InitTypeDef nvic_init;
  nvic_init.NVIC_IRQChannel = I2C1_ER_IRQn;
  nvic_init.NVIC_IRQChannelPreemptionPriority = 1;
  nvic_init.NVIC_IRQChannelSubPriority = 0;
  nvic_init.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&nvic_init);
}

i_tiny_i2c_t* i2c1_init(void) {
  configure_clocks();
  configure_pins();
  configure_event_interrupt();
  configure_error_interrupt();
  configure_i2c1();

  self.interface.api = &api;

  return &self.interface;
}
