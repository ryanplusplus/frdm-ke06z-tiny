diff -Naur lib/patched/FreeRTOS-Kernel/include/FreeRTOS.h patched/FreeRTOS-Kernel/include/FreeRTOS.h
--- lib/patched/FreeRTOS-Kernel/include/FreeRTOS.h	2020-08-16 14:09:18.797822425 -0400
+++ patched/FreeRTOS-Kernel/include/FreeRTOS.h	2020-08-16 08:39:38.062181134 -0400
@@ -161,6 +161,10 @@
         #define INCLUDE_uxTaskGetStackHighWaterMark2    0
     #endif
 
+    #ifndef INCLUDE_pxTaskGetStackStart
+        #define INCLUDE_pxTaskGetStackStart 0
+    #endif
+
     #ifndef INCLUDE_eTaskGetState
         #define INCLUDE_eTaskGetState    0
     #endif
@@ -427,6 +431,22 @@
         #define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
     #endif
 
+    #ifndef traceREADDED_TASK_TO_READY_STATE
+    	#define traceREADDED_TASK_TO_READY_STATE( pxTCB )	traceMOVED_TASK_TO_READY_STATE( pxTCB )
+    #endif
+
+    #ifndef traceMOVED_TASK_TO_DELAYED_LIST
+    	#define traceMOVED_TASK_TO_DELAYED_LIST()
+    #endif
+
+    #ifndef traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST
+    	#define traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST()
+    #endif
+
+    #ifndef traceMOVED_TASK_TO_SUSPENDED_LIST
+    	#define traceMOVED_TASK_TO_SUSPENDED_LIST( pxTCB )
+    #endif
+
     #ifndef traceQUEUE_CREATE
         #define traceQUEUE_CREATE( pxNewQueue )
     #endif
@@ -675,6 +695,18 @@
         #define traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify )
     #endif
 
+    #ifndef traceISR_EXIT_TO_SCHEDULER
+    	#define traceISR_EXIT_TO_SCHEDULER()
+    #endif
+
+    #ifndef traceISR_EXIT
+    	#define traceISR_EXIT()
+    #endif
+
+    #ifndef traceISR_ENTER
+    	#define traceISR_ENTER()
+    #endif
+
     #ifndef traceSTREAM_BUFFER_CREATE_FAILED
         #define traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer )
     #endif
diff -Naur lib/patched/FreeRTOS-Kernel/include/task.h patched/FreeRTOS-Kernel/include/task.h
--- lib/patched/FreeRTOS-Kernel/include/task.h	2020-08-16 14:09:18.809809484 -0400
+++ patched/FreeRTOS-Kernel/include/task.h	2020-08-16 08:40:36.707617391 -0400
@@ -1459,6 +1459,25 @@
 
 /**
  * task.h
+ * <PRE>uint8_t* pxTaskGetStackStart( TaskHandle_t xTask);</PRE>
+ *
+ * INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for
+ * this function to be available.
+ *
+ * Returns the start of the stack associated with xTask.  That is,
+ * the highest stack memory address on architectures where the stack grows down
+ * from high memory, and the lowest memory address on architectures where the
+ * stack grows up from low memory.
+ *
+ * @param xTask Handle of the task associated with the stack returned.
+ * Set xTask to NULL to return the stack of the calling task.
+ *
+ * @return A pointer to the start of the stack.
+ */
+    uint8_t* pxTaskGetStackStart( TaskHandle_t xTask) PRIVILEGED_FUNCTION;
+
+/**
+ * task.h
  * <PRE>configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask );</PRE>
  *
  * INCLUDE_uxTaskGetStackHighWaterMark2 must be set to 1 in FreeRTOSConfig.h for
diff -Naur lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM0/port.c patched/FreeRTOS-Kernel/portable/GCC/ARM_CM0/port.c
--- lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM0/port.c	2020-08-16 14:09:18.889723207 -0400
+++ patched/FreeRTOS-Kernel/portable/GCC/ARM_CM0/port.c	2020-08-16 08:41:54.097389031 -0400
@@ -360,13 +360,19 @@
     uint32_t ulPreviousMask;
 
     ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
+    traceISR_ENTER();
     {
         /* Increment the RTOS tick. */
         if( xTaskIncrementTick() != pdFALSE )
         {
+            traceISR_EXIT_TO_SCHEDULER();
             /* Pend a context switch. */
             portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
         }
+        else
+		{
+			traceISR_EXIT();
+		}
     }
     portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 }
diff -Naur lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM0/portmacro.h patched/FreeRTOS-Kernel/portable/GCC/ARM_CM0/portmacro.h
--- lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM0/portmacro.h	2020-08-16 14:09:18.901710266 -0400
+++ patched/FreeRTOS-Kernel/portable/GCC/ARM_CM0/portmacro.h	2020-08-16 08:42:23.182025573 -0400
@@ -82,7 +82,7 @@
     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
     #define portYIELD()                                 vPortYield()
-    #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
+    #define portEND_SWITCHING_ISR( xSwitchRequired ) { if( xSwitchRequired ) { traceISR_EXIT_TO_SCHEDULER(); portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; } else { traceISR_EXIT(); } }
     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
 /*-----------------------------------------------------------*/
 
diff -Naur lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM3/port.c patched/FreeRTOS-Kernel/portable/GCC/ARM_CM3/port.c
--- lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM3/port.c	2020-08-16 14:09:18.913697323 -0400
+++ patched/FreeRTOS-Kernel/portable/GCC/ARM_CM3/port.c	2020-08-16 08:43:09.299008085 -0400
@@ -437,14 +437,20 @@
      * save and then restore the interrupt mask value as its value is already
      * known. */
     portDISABLE_INTERRUPTS();
+    traceISR_ENTER();
     {
         /* Increment the RTOS tick. */
         if( xTaskIncrementTick() != pdFALSE )
         {
+            traceISR_EXIT_TO_SCHEDULER();
             /* A context switch is required.  Context switching is performed in
              * the PendSV interrupt.  Pend the PendSV interrupt. */
             portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
         }
+		else
+		{
+			traceISR_EXIT();
+		}
     }
     portENABLE_INTERRUPTS();
 }
diff -Naur lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM3/portmacro.h patched/FreeRTOS-Kernel/portable/GCC/ARM_CM3/portmacro.h
--- lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM3/portmacro.h	2020-08-16 14:09:18.917693011 -0400
+++ patched/FreeRTOS-Kernel/portable/GCC/ARM_CM3/portmacro.h	2020-08-16 08:43:37.443593579 -0400
@@ -90,7 +90,7 @@
 
     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
-    #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD()
+    #define portEND_SWITCHING_ISR( xSwitchRequired ) {} if( xSwitchRequired != pdFALSE ) { traceISR_EXIT_TO_SCHEDULER(); portYIELD() } else { traceISR_EXIT(); } }
     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
 /*-----------------------------------------------------------*/
 
diff -Naur lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM4F/port.c patched/FreeRTOS-Kernel/portable/GCC/ARM_CM4F/port.c
--- lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM4F/port.c	2020-08-16 14:09:18.933675755 -0400
+++ patched/FreeRTOS-Kernel/portable/GCC/ARM_CM4F/port.c	2020-08-16 08:44:24.480551704 -0400
@@ -499,14 +499,20 @@
      * save and then restore the interrupt mask value as its value is already
      * known. */
     portDISABLE_INTERRUPTS();
+    traceISR_ENTER()
     {
         /* Increment the RTOS tick. */
         if( xTaskIncrementTick() != pdFALSE )
         {
+            traceISR_EXIT_TO_SCHEDULER();
             /* A context switch is required.  Context switching is performed in
              * the PendSV interrupt.  Pend the PendSV interrupt. */
             portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
         }
+		else
+		{
+			traceISR_EXIT();
+		}
     }
     portENABLE_INTERRUPTS();
 }
diff -Naur lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM4F/portmacro.h patched/FreeRTOS-Kernel/portable/GCC/ARM_CM4F/portmacro.h
--- lib/patched/FreeRTOS-Kernel/portable/GCC/ARM_CM4F/portmacro.h	2020-08-16 14:09:18.933675755 -0400
+++ patched/FreeRTOS-Kernel/portable/GCC/ARM_CM4F/portmacro.h	2020-08-16 08:44:51.588380081 -0400
@@ -90,7 +90,7 @@
 
     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
-    #define portEND_SWITCHING_ISR( xSwitchRequired )    if( xSwitchRequired != pdFALSE ) portYIELD()
+    #define portEND_SWITCHING_ISR( xSwitchRequired ) { if( xSwitchRequired != pdFALSE ) { traceISR_EXIT_TO_SCHEDULER(); portYIELD(); } else { traceISR_EXIT(); } }
     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
 /*-----------------------------------------------------------*/
 
diff -Naur lib/patched/FreeRTOS-Kernel/tasks.c patched/FreeRTOS-Kernel/tasks.c
--- lib/patched/FreeRTOS-Kernel/tasks.c	2020-08-16 14:09:19.493095913 -0400
+++ patched/FreeRTOS-Kernel/tasks.c	2020-08-16 08:52:11.999999330 -0400
@@ -222,6 +222,18 @@
     taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                                                \
     vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
     tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
+
+
+/*
+ * Place the task represented by pxTCB which has been in a ready list before
+ * into the appropriate ready list for the task.
+ * It is inserted at the end of the list.
+ */
+#define prvReaddTaskToReadyList( pxTCB )															\
+	traceREADDED_TASK_TO_READY_STATE( pxTCB );														\
+	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
+	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
+	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 /*-----------------------------------------------------------*/
 
 /*
@@ -1690,7 +1702,7 @@
                         mtCOVERAGE_TEST_MARKER();
                     }
 
-                    prvAddTaskToReadyList( pxTCB );
+                    prvReaddTaskToReadyList( pxTCB );
                 }
                 else
                 {
@@ -1752,6 +1764,7 @@
                 mtCOVERAGE_TEST_MARKER();
             }
 
+            traceMOVED_TASK_TO_SUSPENDED_LIST(pxTCB);
             vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 
             #if ( configUSE_TASK_NOTIFICATIONS == 1 )
@@ -3934,6 +3947,20 @@
 #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
 /*-----------------------------------------------------------*/
 
+#if (INCLUDE_pxTaskGetStackStart == 1)
+	uint8_t* pxTaskGetStackStart( TaskHandle_t xTask)
+	{
+	    TCB_t *pxTCB;
+	    UBaseType_t uxReturn;
+        (void)uxReturn;
+
+		pxTCB = prvGetTCBFromHandle( xTask );
+		return ( uint8_t * ) pxTCB->pxStack;
+	}
+
+#endif /* INCLUDE_pxTaskGetStackStart */
+/*-----------------------------------------------------------*/
+
 #if ( INCLUDE_vTaskDelete == 1 )
 
     static void prvDeleteTCB( TCB_t * pxTCB )
@@ -4105,7 +4132,7 @@
 
                     /* Inherit the priority before being moved into the new list. */
                     pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
-                    prvAddTaskToReadyList( pxMutexHolderTCB );
+                    prvReaddTaskToReadyList( pxMutexHolderTCB );
                 }
                 else
                 {
@@ -4195,7 +4222,7 @@
                      * any other purpose if this task is running, and it must be
                      * running to give back the mutex. */
                     listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
-                    prvAddTaskToReadyList( pxTCB );
+                    prvReaddTaskToReadyList( pxTCB );
 
                     /* Return true to indicate that a context switch is required.
                      * This is only actually required in the corner case whereby
@@ -5302,6 +5329,7 @@
                 /* Add the task to the suspended task list instead of a delayed task
                  * list to ensure it is not woken by a timing event.  It will block
                  * indefinitely. */
+                traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
                 vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
             }
             else
@@ -5318,12 +5346,14 @@
                 {
                     /* Wake time has overflowed.  Place this item in the overflow
                      * list. */
+                    traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
                     vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
                 }
                 else
                 {
                     /* The wake time has not overflowed, so the current block list
                      * is used. */
+                    traceMOVED_TASK_TO_DELAYED_LIST();
                     vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 
                     /* If the task entering the blocked state was placed at the
@@ -5353,11 +5383,13 @@
             if( xTimeToWake < xConstTickCount )
             {
                 /* Wake time has overflowed.  Place this item in the overflow list. */
+                traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
                 vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
             }
             else
             {
                 /* The wake time has not overflowed, so the current block list is used. */
+                traceMOVED_TASK_TO_DELAYED_LIST();
                 vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 
                 /* If the task entering the blocked state was placed at the head of the
